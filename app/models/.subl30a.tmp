var mongoose = require('mongoose');
var bcrypt   = require('bcrypt-nodejs');
var _        = require('underscore');

var isValidPassword = function(password) {
    // Very lax conditions for now, I will develop a 
    // more elaborate password validation scheme later
    return password.length > 5;
};

var UserSchema = new mongoose.Schema({
    first_name           : {type: String, required: true},
    last_name            : {type: String, required: true},
    username             : {type: String, required: true, unique: true},
    email                : {type: String, required: true, unique: true},
    password             : {type: String, required: true},
    rank                 : {type: Number, required: true, default: 1200},
    online               : {type: Boolean, required: true, default: false},
    sent_friend_requests : [{type: mongoose.Schema.Types.ObjectId, ref: 'User'}],
    recv_friend_requests : [{type: mongoose.Schema.Types.ObjectId, ref: 'User'}],
    friends              : [{type: mongoose.Schema.Types.ObjectId, ref: 'User'}]
});

UserSchema.methods.isCorrectPassword = function(password) {
    return bcrypt.compareSync(password, this.password);
};

UserSchema.methods.toSafeObject = function() {
    return {
        first_name: this.first_name,
        last_name: this.last_name,
        username: this.username,
        email: this.email,
        online: this.online,
        rank: this.rank
    };
};

UserSchema.methods.friendStatus = function(user) {
    var get = function(field, user) {
        var populated = user.populated(field);
        return _.map(user[field], function(f) {
            return populated ? f.id : f.toString();
        });
    };

    var friends = get('friends', this);
    var sent = get('sent_friend_requests', this);
    var recv = get('recv_friend_requests', this);

    if(_.contains(friends, user.id)) {
        return 'friends';
    } else if(_.contains(sent, user.id)) {
        return 'sent';
    } else if(_.contains(recv, user.id)) {
        return 'received';
    }
    return 'none';
};

UserSchema.methods.areFriends = function(user) {
    return this.friendStatus(user) === 'friends';
}

UserSchema.methods.hasSentFriendRequest = function(user) {
    return this.friendStatus(user) === 'sent';
}

UserSchema.methods.hasRecvFriendRequest = function(user) {
    return this.friendStatus(user) === 'received';
}

UserSchema.methods.advanceFriendStatus = function(user, callback) {
    /* 
     * The user through which this function is initiated is considered
     * as the sender of the request. May also be used to accept requests.
     * 
     * The callback is called with one argument: the status of the friendship
     * after executing the function
     */
    var currentStatus = this.friendStatus(user);
    var modified      = false;
    var thisUser      = this; // closure for callbacks...

    if(currentStatus === 'none') {
        thisUser.sent_friend_requests.push(user)
        user.recv_friend_requests.push(thisUser)
        modified = true;
    } else if(currentStatus === 'received') {
        var remove = function(field, user, toRemove) {
            var populated = user.populated(field);
            user[field] = _.filter(user[field], function(u) {
                return populated ? (u.id !== toRemove.id) : (u.toString() !== toRemove.id);
            });
        };

        console.log("R1: " + this.recv_friend_requests);
        remove('recv_friend_requests', this, user);
        console.log("R2: " + this.recv_friend_requests);
        remove('sent_friend_requests', user, this);
        modified = true;
    }

    if(modified) {
        thisUser.save(function(err) {
            user.save(function(err) {
                callback(thisUser.friendStatus(user));
            });
        });
    } else {
        callback(currentStatus);
    } 
}

UserSchema.pre('save', function(next) {
    if(!this.isNew) {
        next();
    } else if(isValidPassword(this.password)) {
        this.password = bcrypt.hashSync(this.password, bcrypt.genSaltSync());
        next();
    } else {
        next(new Error("invalid password"));
    }
});

module.exports = mongoose.model('User', UserSchema);